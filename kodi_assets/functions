#! /opt/bin/bash
# c plgroves gmail 2022
# pia-foss-wireguard kodi functions

  # add kodi GUI.Notifications with timeouts and images
  #     _pia_notify 'message' 'display time' 'image file'
  # logging function
  #     _logger 'message' [ logfile ]
  # This section allows reading from a tee
  #
   # wait for stdin
     #sleep 0.01
     #if read -t 0
   #
   # e.g. echo "Hello World" | tee >(_pia_notify [displaytime [image]]) >/dev/null
   # or  echo "Hello World" |
   #     tee >( _logger [log [source]]) >(_is_not_tty && _pia_notify [displaytime [image]]) >/dev/null
   #
  #
  # get file creation time 
  # check interval now and then
  # convert seconds to 'X hrs Y mins Z secs'
  # check for empty/unset variables n.b. test unset passes VARIABLE NAME ONLY
  # run is interactive or not

  # credentials for local kodi
    kodi_user=kodi
    kodi_pass=
    kodi_host=localhost
    kodi_port=8080

  # logs to systemd journal, and/or screen and log file
    function _logger() {
        local message log source tab spaces date

      # This section allows reading from a tee
      # e.g. echo "Hello World" | tee >(_logger [log [source]]) >/dev/null
      # wait for stdin
        sleep 0.01
        if read -t 0
      # there is something in stdin put it in ${@:1}
        then read -r new_one
             [[ -n "${new_one}" ]] \
               && set -- "${new_one}" "${@:1:2}"
        fi
      #
      #
        message="${1:-lorem ipsum dolor sit amet}"
        log="${2:-$LOG}"
      # in case $LOG is not set
        log="${log:-/dev/null}"
        source="${3:-$(caller)}"
        tab=$((${#source}+1))
        IFS="" spaces="$(printf "%$((tab*2))s")"
        TZ="$( awk -F, 'END {print $1}' < <(strings /etc/localtime))"
        date="$(TZ="${TZ}" /opt/bin/date)"

      # running non-interactively but not from systemd: print to stdout and $log
        _is_unset PRE_UP_RUN \
        && \
        printf %s:[%s]:%.$((${tab}-${#source}))s%s%s  "${date}" "$(cut -d- -f2- <<< "${source##*/}") " "${spaces} " "${message}" $'\n'| tee -a "${log}" \
        ||
        echo "${message}"
      # send message to stdout
           # cat to systemd journal
             #systemd-cat -t pia-wireguard -p warning <<< "${message}"
    }
  export -f _logger

  # match 'value' in kodi json
    function _parse_JSON {
        local key=$1
        /usr/bin/awk -F"[,:}]" \
                     '{for(i=1;i<=NF;i++)
                      {if($i~/'"${key}"'\042/)
                         {print $(i+1)}}}' \
                   | tr -d '"'
 }
  export -f _parse_JSON

  # send request to kodi json api
    function _kodi_REQ {
        /opt/bin/curl --silent -X POST --header "Content-Type: application/json" -d "$1" http://$kodi_user:$kodi_pass@$kodi_host:$kodi_port/jsonrpc
 }
  export -f _kodi_REQ

    function _pia_notify() {
        local message displaytime image image_path show_image

      # This section allows reading from a tee
      # e.g. echo "Hello World" | tee >(_pia_notify [displaytime [image]]) >/dev/null
      # wait for stdin
        sleep 0.01
        if read -t 0
      # there is something in stdin put it in ${@:1}
        then read -r new_one
             [[ -n "${new_one}" ]] \
               && set -- "${new_one}" "${@:1:2}"
        fi
        #
        #
        message="${1:-lorem ipsum dolor sit amet}"
        displaytime="${2:-5000}"
      # set default image file name
        image="${3:-"pia_on_48x48.png"}"
      # assume ./kodi_assets, and all scripts set working directory
        image_path="$(pwd)/kodi_assets"
        [[ -s "${image_path}/${image}" ]] \
           && show_image=',"image":"'"${image_path}/${image}"'"'

        status="$( _parse_JSON 'result' < <(_kodi_REQ ' {"jsonrpc": "2.0", "method": "GUI.ShowNotification", "params": {"title": "PIA Wireguard Connection", "message": "'"${message}"'" , "displaytime": '"${displaytime}"''"${show_image}"' }, "id": 1} '))"

        [[ "$status" =~ OK ]] \
        || return 1
        return 0
 }
  export -f _pia_notify

  # epoch creation time of file
    function _created() {
        /opt/bin/stat -c %Y "${1}" 2>/dev/null \
                 || \
                 echo $?
        return 0
 }
    export -f _created

  # interval between now and then
    function _interval() {
        local now 'then'
        then="${1:-1}"
    
        now="$(printf '%(%s)T' \
                    | tee "${2:-/dev/null}")"
        echo -n "$((now-${then}))"
    return 0
 }
    export -f _interval

  # convert seconds to X hrs Y mins Z secs
    function _hmmss() {
        local time="$1"
        local h m s
        ((s=time%60, time/=60, m=time%60, h=time/60))
        printf "%d hrs %02d mins %02d secs" "${h#-}" "${m#-}" "${s#-}"
 }
    export -f _hmmss

  # check variable unset
    function _is_unset() {
        local VarName=$1
        [[ -z ${!VarName+y} ]]
 }
    export -f _is_unset

  # check variable empty
    function _is_empty() {
        [[ -z "${1}" ]]
 } #
    export -f _is_empty

  # running interactively
    function _is_tty() {
        [[ -t 0 || -n "${SSH_TTY}" ]]
 }
    export -f _is_tty

  # not running interactively
    function _is_not_tty() {
        ! [[ -t 0 || -n "${SSH_TTY}" ]]
 }
    export -f _is_not_tty

    function _print_connection_instructions() {
        
        if _is_tty
      # running interactively
        then
             echo -e "to connect manually go to"
             echo -e "\tSettings > Coreelec > Connections, select WireGuard and connect"
             echo -e "\t    This may not set DNS and"
             echo -e "\t    WILL NOT set iptables killswitch!?"
             echo -e "\tiptables-restore $(pwd)/rules-wireguard.v4     WILL!"
             echo
             echo  -e "\tTo (re)enable port forwarding run\n" 
             echo -e "    PIA_TOKEN=$PIA_TOKEN PF_GATEWAY=$WG_SERVER_IP PF_HOSTNAME=$WG_HOSTNAME $(pwd)/port_forwarding.sh"
             if [[ "${PIA_PF}" != 'true' ]]
           # add caveat
             then
                  echo
                  echo -e "\tThe location used must be port forwarding enabled, or this will fail."
                  echo -e "\tCall PIA_PF=true $(pwd)/get_region for a filtered list."
             fi
             echo -e "\n\tport_forwading.sh must be left running to maintain the port"
             echo -e "\tIt WILL TIE UP A CONSOLE unless run in the background"
             echo
        else
      # running non-interactively, log and Gui.Notifications
        # two lines that require scrolling really mess up estuary etc.
        # and some skins don't scroll and limit the number of lines
             echo 'Saved configuration for '"${REGION_NAME}"' ' |
              tee >(_logger) >(_pia_notify)
             sleep 5
             echo "Goto Settings>Coreelec>Connections" |
              tee >(_logger) >(_pia_notify 10000 )
             sleep 10
             echo "This precludes port forwarding and setting a safe firewall" |
              tee >(_logger) >(_pia_notify 6000 'pia_off_48x48.png')
             sleep 6
             echo "Set CONNMAN_CONNECT=true to avoid this" |
              tee >(_logger) >(_pia_notify 6000 'pia_off_48x48.png')
             sleep 6
        fi
    return 0
 }
    export -f _print_connection_instructions
